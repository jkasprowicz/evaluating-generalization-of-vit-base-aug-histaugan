import torch
from torchvision import datasets, transforms
from torch.utils.data import DataLoader
import timm
from ultralytics import YOLO
import numpy as np
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
from tqdm import tqdm
import os

# -----------------------------------------------------------------------------
# 1. PAINEL DE CONTROLO - AJUSTE ESTES PAR√ÇMETROS
# -----------------------------------------------------------------------------

# --- Defini√ß√µes do Modelo ---
# Escolha o tipo de modelo: 'vit' ou 'yolo'
MODEL_TYPE = 'vit'
# Caminho para os pesos do seu modelo treinado
MODEL_WEIGHTS_PATH = '/lapix/vit_base_multilabel_best.pth'

# --- Defini√ß√µes do Dataset P√∫blico ---
PUBLIC_DATASET_PATH = 'LISC_cropped'

# --- Configura√ß√µes de Avalia√ß√£o ---
IMAGE_SIZE = 384 if MODEL_TYPE == 'vit' else 640
BATCH_SIZE = 32

# --- MAPEAMENTO DE CLASSES (A PARTE MAIS IMPORTANTE) ---
# Mapeie o nome da pasta do dataset p√∫blico (chave) para o nome da classe do SEU modelo (valor)
# Adapte este dicion√°rio para cada dataset que for testar!
CLASS_MAPPING = {
    # Mapeamento CORRIGIDO para o dataset LISC (case-sensitive)
    'Baso': 'Basofilo',
    'eosi': 'Eosinofilo',
    'lymp': 'Linfocito',
    'mono': 'Monocito',
    'neut': 'Neutrofilo segmentado',
    # Ignorar a pasta 'mixt' que existe no LISC mas n√£o nos interessa
    'mixt': None
}

# Lista das 14 classes com as quais SEU MODELO foi treinado, na ordem EXATA de treino
# (Baseado na sua extra√ß√£o do _classes.csv)
YOUR_MODEL_CLASSES = [
    'Artefato', 'Basofilo', 'Bastonete', 'Blasto', 'Eosinofilo', 'Eritroblasto',
    'Linfocito', 'Linfocito atipico', 'Metamielocito', 'Mielocito', 'Monocito',
    'Neutrofilo segmentado', 'Promielocito', 'Restos celulares'
]

# -----------------------------------------------------------------------------
# 2. L√ìGICA DO SCRIPT (Normalmente n√£o precisa de alterar abaixo)
# -----------------------------------------------------------------------------

def load_model(model_type, weights_path, num_classes):
    """Carrega o modelo (ViT ou YOLO) com os pesos treinados."""
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"üöÄ Usando dispositivo: {device}")

    model = None
    if model_type == 'vit':
        model = timm.create_model('vit_base_patch16_384', pretrained=False, num_classes=num_classes)
        model.load_state_dict(torch.load(weights_path, map_location=device))
        print("‚úÖ Modelo ViT carregado com sucesso.")
    elif model_type == 'yolo':
        model = YOLO(weights_path)
        print("‚úÖ Modelo YOLO carregado com sucesso.")
    else:
        raise ValueError("Tipo de modelo inv√°lido. Escolha 'vit' ou 'yolo'.")

    if model:
        model.to(device)
        model.eval()
    return model, device

def get_data_loader(dataset_path, image_size, batch_size):
    """Cria um DataLoader para o dataset p√∫blico."""
    if not os.path.exists(dataset_path):
        raise FileNotFoundError(f"O diret√≥rio do dataset p√∫blico n√£o foi encontrado em: {dataset_path}")
        
    transform = transforms.Compose([
        transforms.Resize((image_size, image_size)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    dataset = datasets.ImageFolder(root=dataset_path, transform=transform)
    loader = DataLoader(dataset, batch_size=batch_size, shuffle=False)

    print(f"\nüìÅ Dataset p√∫blico carregado de: {dataset_path}")
    print(f"Found classes: {dataset.classes}")
    return loader, dataset.classes

def evaluate(model, loader, device, model_type, model_classes, public_classes, class_mapping):
    """Executa a avalia√ß√£o e retorna as predi√ß√µes e r√≥tulos verdadeiros."""
    all_preds = []
    all_labels = []
    
    idx_to_model_class = {i: name for i, name in enumerate(model_classes)}

    with torch.no_grad():
        for images, labels in tqdm(loader, desc="üß™ Avaliando"):
            images = images.to(device)
            
            outputs = None
            if model_type == 'vit':
                outputs = model(images)
            elif model_type == 'yolo':
                results = model(images)
                outputs = torch.stack([res.probs.data for res in results]).to(device)

            _, predicted_indices = torch.max(outputs, 1)

            predicted_indices = predicted_indices.cpu().numpy()
            labels = labels.cpu().numpy()

            for i in range(len(labels)):
                true_public_class_name = public_classes[labels[i]]
                mapped_model_class_name = class_mapping.get(true_public_class_name)

                if mapped_model_class_name is None:
                    continue

                pred_model_class_name = idx_to_model_class[predicted_indices[i]]

                all_labels.append(mapped_model_class_name)
                all_preds.append(pred_model_class_name)

    return all_labels, all_preds

def generate_report(true_labels, pred_labels, mapped_classes):
    """Gera e exibe o relat√≥rio de classifica√ß√£o e a matriz de confus√£o."""
    print("\n\n--- üìä Relat√≥rio de Classifica√ß√£o no Dataset P√∫blico ---")
    
    target_names = sorted(list(set(mapped_classes)))
    
    # CORRE√á√ÉO: Adicionado o par√¢metro 'labels=target_names' para for√ßar
    # a avalia√ß√£o apenas nas classes de interesse, resolvendo o ValueError.
    report = classification_report(true_labels, pred_labels, labels=target_names, target_names=target_names, zero_division=0)
    print(report)

    cm = confusion_matrix(true_labels, pred_labels, labels=target_names)
    df_cm = pd.DataFrame(cm, index=target_names, columns=target_names)

    plt.figure(figsize=(10, 8))
    sns.heatmap(df_cm, annot=True, fmt='d', cmap='Blues')
    plt.title(f'Matriz de Confus√£o - {os.path.basename(PUBLIC_DATASET_PATH)}')
    plt.ylabel('Classe Verdadeira')
    plt.xlabel('Classe Predita')
    plt.tight_layout()
    
    output_filename = f"matriz_confusao_{os.path.basename(PUBLIC_DATASET_PATH)}.png"
    plt.savefig(output_filename)
    print(f"\nüíæ Matriz de confus√£o salva em: {output_filename}")
    plt.show()

def main():
    """Fun√ß√£o principal que orquestra o processo."""
    model, device = load_model(MODEL_TYPE, MODEL_WEIGHTS_PATH, len(YOUR_MODEL_CLASSES))
    loader, public_classes = get_data_loader(PUBLIC_DATASET_PATH, IMAGE_SIZE, BATCH_SIZE)

    mapped_classes_to_evaluate = [v for v in CLASS_MAPPING.values() if v is not None]
    print(f"Classes mapeadas para avalia√ß√£o: {sorted(mapped_classes_to_evaluate)}")
    
    # Valida√ß√£o do mapeamento
    for public_cls in CLASS_MAPPING.keys():
        if public_cls not in public_classes:
            print(f"‚ö†Ô∏è Aviso: A classe '{public_cls}' do seu mapeamento n√£o foi encontrada nas pastas do dataset.")

    true_labels, pred_labels = evaluate(model, loader, device, MODEL_TYPE, YOUR_MODEL_CLASSES, public_classes, CLASS_MAPPING)

    if not true_labels:
        print("\n‚ùå Nenhuma amostra foi avaliada. Verifique se os nomes das pastas do dataset p√∫blico correspondem √†s chaves do CLASS_MAPPING.")
        return

    generate_report(true_labels, pred_labels, mapped_classes_to_evaluate)

if __name__ == '__main__':
    main()
